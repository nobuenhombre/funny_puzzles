Четыре монеты
=============

Здесь необходимо какой то логикой вывести одну из четырех монет чтобы осталось 3 монеты
для 3-х монет алгоритм расписан

нужно определить одинаковые монеты


m1 + m2 == m3 + m4
не выполнится никогда как бы мы не переставляли индексы
потому что одна монета фальшивая

соответсвенно прийдется сравнивать только ПО две монеты
НО тут появляются альтернативы по сравнению с 02-coins.txt

Вариант 1
---------
Взвешивание 1.1
- m1 == m2 -> m1G,m2G-ИСТИННЫЕ, m3, m4 - под подозрением

Далее берем любую истинную монету
и вступают правила 03-coins.txt

Взвешивание 1.2
- m1G == m3 -> m3G-ИСТИННАЯ, m4-ФАЛЬШИВКА
или
- m1G != m3 -> m3-ФАЛЬШИВКА, m4G-ИСТИННАЯ

Вариант 2
---------
Взвешивание 2.1
- m1 != m2 -> m3G, m4G - истинные, m1, m2 - под подозрением

Взвешивание 2.2
- m3G == m1 -> m1G-ИСТИННАЯ, m2-ФАЛЬШИВКА
или
- m3G != m1 -> m1-ФАЛЬШИВКА, m2G-ИСТИННАЯ

ВЫВОДЫ
======
ГРУППА из 4-х монет
МИНИМАЛЬНОЕ число взвешиваний = 2
МАКСИМАЛЬНОЕ число взвешиваний = 2

Схема взвешиваний описана.

МОЯ КЛИНОПИСЬ
=============

1.1  [m1? == m2?]  -> @ m1G, m2G, m3?, m4? @
1.2A [m1G == m3?]  -> $ m1G, m2G, m3G, m4F $
1.2B [m1G !== m3?] -> $ m1G, m2G, m3F, m4G $

2.1  [m1? != m2?] -> @ m1?, m2?, m3G, m4G @
2.2A [m3G == m1?] -> $ m1G, m2F, m3G, m4G $
2.2B [m3G != m1?] -> $ m1F, m2G, m3G, m4G $